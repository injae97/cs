## 💡 캐시 기본 동작
    a. 캐시가 없을 때
        - 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.
        - 인터넷 네트워크는 매우 느리고 비싸다.
        - 브라우저 로딩 속도가 느리다.
        - 느린 사용자 경험 
        
        e.g 캐시가 없을 때(첫 번째 요청)
        1. 웹 브라우저(요청 1) -> 서버
        
        웹 브라우저
        GET/ star.jpg
        
        서버
        HTTP/1.1 200 OK
        Content-Type: image/jpeg
        Content-Length: 34012
        
        lkj123kljoasdnjsadkasjldnjn123498iasdnjklasdnjksadnasjkdn12i3u4uiasdnjk123ejiodoji12ojiue3njmkl
        
        2. 서버(응답) -> 웹 브라우저 
        
        서버
        star.jpg
        
        1.1M 가정
        HTTP 헤더: 0.1M
        HTTP 바디: 1.0M
        
        서버가 클라이언트에게 1.1 M 전송 1 
        
        e.g 캐시가 없을 때(두 번째 요청)
        1. 웹 브라우저(요청 2) -> 서버
        
        웹 브라우저
        GET/ star.jpg
        
        서버
        HTTP/1.1 200 OK
        Content-Type: image/jpeg
        Content-Length: 34012
        
        lkj123kljoasdnjsadkasjldnjn123498iasdnjklasdnjksadnasjkdn12i3u4uiasdnjk123ejiodoji12ojiue3njmkl
        
        2. 서버(응답) -> 웹 브라우저 
        
        서버
        star.jpg
        
        1.1M 가정
        HTTP 헤더: 0.1M
        HTTP 바디: 1.0M
        
        서버가 클라이언트에게 1.1 M 전송 2 
    
    b. 캐시 적용
        - 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
        - 비싼 네트워크 사용량을 줄일 수 있다.
        - 브라우저 로딩 속도가 매우 빠르다.
        - 빠른 사용자 경험
        
        e.g 캐시 적용(첫 번째 요청)
        1. 웹 브라우저(요청 1) -> 서버
        
        웹 브라우저
        GET/ star.jpg
        
        서버
        HTTP/1.1 200 OK
        Content-Type: image/jpeg
        cache-control: max-age=60(캐시가 유효한 시간(초))
        Content-Length: 34012
        
        lkj123kljoasdnjsadkasjldnjn123498iasdnjklasdnjksadnasjkdn12i3u4uiasdnjk123ejiodoji12ojiue3njmkl
        
        * 브라우저 캐시: 응답 결과를 캐시에 저장(60초 유효)        
        
        e.g 캐시 적용(두 번째 요청) - 캐시 시간 유효 
        1. 웹 브라우저(요청 2) -> 브라우저 캐시(캐시 유효 시간 검증(60초 유효))
          
        웹 브라우저
        GET/ star.jpg
        
        * 캐시가 유효 하다면 캐시에서 조회 
                    
    c. 캐시 시간 초과
        - 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.
        - 이때 다시 네트워크 다운로드가 발생한다.
        
        e.g 캐시 적용(세 번째 요청) - 캐시 시간 초과
        1. 웹 브라우저(요청 3) -> 브라우저 캐시(캐시 유효 시간 검증(60초 초과))
        
        웹 브라우저
        GET/ star.jpg
        
        * 웹 브라우저 -> 브라우저 캐시(캐시 60초 초과 -> 다시 요청)
        
        웹 브라우저
        GET/ star.jpg
        
        서버
        HTTP/1.1 200 OK
        Content-Type: image/jpeg
        cache-control: max-age=60(캐시가 유효한 시간(초))
        Content-Length: 34012
        
        lkj123kljoasdnjsadkasjldnjn123498iasdnjklasdnjksadnasjkdn12i3u4uiasdnjk123ejiodoji12ojiue3njmkl
        
        1.1M 가정
        HTTP 헤더: 0.1M
        HTTP 바디: 1.0M
        
        서버가 클라이언트에게 1.1 M 전송 3
        
        * 브라우저 캐시: 응답 결과를 다시 캐시에 저장 
        * 캐시 시간은 지났지만 이미지가 같은 파일 이라면 다시 받아야 할까? 
        
## 💡 검증 헤더와 조건부 요청 1
    a. 검증 헤더(Last-Modified)
        - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
    
    b. 조건부 요청 헤더(if-modified-since)
        - 검증 헤더로 조건에 따른 분기

    * 캐시 시간 초과
        - 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.
            1. 서버에서 기존 데이터를 변경함
            2. 서버에서 기존 데이터를 변경하지 않음(똑같은 데이터 = 이미지 같은 파일)
                - 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있다.
                - 단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요
                    e.g 검증 헤더 추가(첫 번째 요청)
                    
                    1. 웹 브라우저(요청) -> 서버
                    
                    웹 브라우저
                    GET/ star.jpg
                    
                    서버
                    HTTP/1.1 200 OK
                    Content-Type: image/jpeg
                    cache-control: max-age=60(캐시가 유효한 시간(초))
                    Last-Modified: 2020-11-10T10:00:00+00:00(데이터가 마지막에 수정된 시간)
                    Content-Length: 34012
                    
                    lkj123kljoasdnjsadkasjldnjn123498iasdnjklasdnjksadnasjkdn12i3u4uiasdnjk123ejiodoji12ojiue3njmkl
                    
                    2. 서버(응답) -> 웹 브라우저 
                    
                    서버
                    star.jpg
                    
                    1.1M 가정
                    HTTP 헤더: 0.1M
                    HTTP 바디: 1.0M
                    
                    서버가 클라이언트에게 1.1 M 전송 1     
                    * 브라우저 캐시: 응답 결과를 캐시에 저장(데이터 최종 수정일(2020-11-10T10:00:00+00:00))
                    
                    e.g 검증 헤더 추가(두 번째 요청) - 캐시 시간 초과
                    
                    1. 웹 브라우저(요청) -> 브라우저 캐시
                    
                    웹 브라우저
                    GET/ star.jpg
                    
                    * 웹 브라우저가 브라우저 캐시한테 요청(캐시 60초 초과)
                    
                    2. 웹 브라우저 -> 서버(검증 헤더 요청 1)
                    
                    웹 브라우저
                    GET/ star.jpg
                    if-modified-since: 2020-11-10T10:00:00+00:00
                    
                    * 브라우저 캐시: 응답 결과를 캐시에 저장(데이터 최종 수정일(2020-11-10T10:00:00+00:00))
                    * 브라우저 캐시가 가지고 있는 데이터 최종 수정일을 붙인 다음 보냄(if-modified-since)
                    
                    3. 서버 -> 웹 브라우저(검증 헤더 요청 2)
                    * 서버에서 날짜를 보고 데이터 검증
                        - 웹브라우저 = 서버(데이터가 아직 수정되지 않았다)
                    
                    서버 
                    HTTP/1.1 304 Not Modified
                    Content-Type: image/jpeg
                    cache-control: max-age=60
                    Last-Modified: 2020-11-10T10:00:00+00:00
                    Content-Length: 34012
                    
                    * HTTP Body가 없음 
                    
                    star.jpg
                    0.1M 가정
                    HTTP 헤더: 0.1M
                    
                    서버가 클라이언트에게 0.1 M 전송(HTTP Body 전송 X)
                    
                    * 304 Not Modified(데이터가 변경되지 않았구나 그렇기 때문에 그대로 사용하면 되는구나 라고 생각)
                        - 브라우저 캐시: 응답 결과를 재사용, 헤더 데이터 갱신(60초 유효)
                        - 데이터 최종 수정일(2020-11-10T10:00:00+00:00))
                        
                    4. 브라우저 캐시 -> 웹 브라우저 (캐시에서 조회)
                        - 데이터 최종 수정일(2020-11-10T10:00:00+00:00)
    
    * 정리
        - 캐시 유효 시간이 초과해도 서버의 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보만 응답(HTTP Body 제외)
            * HTTP 헤더 데이터만 다운로드함
        - 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
        - 클라이언트는 캐시에 저장되어 있는 데이터 재활용
        - 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드
        - 매우 실용적인 해결책
        
## 💡 검증 헤더와 조건부 요청 2
    a. 검증 헤더
        - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
            e.g Last-Modified, ETag
    
    b. 조건부 요청 헤더
        - 검증 헤더로 조건에 따른 분기
            e.g if-modified-since: Last-Modified 사용
                * if-modified-since: 이후에 데이터가 수정되었으면?
                    a. 데이터 미변경 예시
                        - 캐시: 2020-11-10T10:00:00+00:00 vs 서버: 2020-11-10T10:00:00+00:00 
                        - 304 Not Modified, 헤더 데이터만 전송(HTTP Body 미포함)
                            - 전송 용량 0.1M(헤더 0.1M, 바디 1.0M)
                            
                    b. 데이터 변경 예시
                        - 캐시: 2020-11-10T10:00:00+00:00 vs 서버: 2020-11-10T11:00:00+00:00 
                        - 200 OK, 모든 데이터 전송(HTTP Body 포함)
                            - 전송 용량 1.1M(헤더 0.1M, 바디 1.0M)
                                        
            e.g if-None_Match: ETag 사용
                - 조건이 만족하면 200 OK
                - 조건이 만족하지 않으면 304 Not Modified
    